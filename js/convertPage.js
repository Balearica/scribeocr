
function round6(x){
    return(Math.round(x*1e6)/1e6);
}

onmessage = function(e) {
  let workerResult;
  if(e.data[2]){
    workerResult = [convertPageAbbyy(e.data[0], e.data[1]),e.data[1]];
  } else {
    workerResult = [convertPage(e.data[0]),e.data[1]];
  }
  workerResult.push(e.data[3], e.data[4]);
  postMessage(workerResult);
}


function quantile(arr, ntile){
  if(arr.length == 0){
    return null
  }
  const mid = Math.floor(arr.length * ntile)
  arr.sort((a, b) => a - b);

  return arr[mid];
};

const mean50 = arr => {
  if(arr.length == 0){
    return null;
  }
  const per25 = Math.floor(arr.length / 4) - 1;
  const per75 = Math.ceil(arr.length * 3 / 4) - 1;
  const nums = [...arr].sort((a, b) => a - b);
  const numsMiddle = nums.slice(per25, per75+1);

  return numsMiddle.reduce((a, b) => a + b) / numsMiddle.length;
;
};


function convertPage(hocrString){

  let widthObjPage = { "normal": {} };
  let heightObjPage = { "normal": {} };
  let heightSmallCapsObjPage = new Object;
  let cutObjPage = { "normal": {} };
  let kerningObjPage = { "normal": {} };

  var angleRisePage = new Array;
  var lineLeft = new Array;
  var lineTop = new Array;

  let pageDims = [null,null];
  let pageElement = hocrString.match(/<div class=[\"\']ocr_page[\"\'][^\>]+/i);
  if(pageElement != null){
    pageElement = pageElement[0];
    pageDims = pageElement.match(/bbox \d+ \d+ (\d+) (\d+)/i);
    pageDims = [parseInt(pageDims[2]),parseInt(pageDims[1])];
  }

  // Test whether character-level data (class="ocrx_cinfo" in Tesseract) is present.
  const charMode = /ocrx_cinfo/.test(hocrString) ? true : false;

  // Test whether cuts are present.
  // This will be the case for users re-importing HOCR generated by the site.
  //const cutsMode = /\<span[^\>]*cuts/i.test(hocrString) ? true : false;

  // The JavaScript regex engine does not support matching start/end tags (some other engines do), so the end of words and lines are detected
  // through a hard-coded number of </span> end tags.  The only difference charMode should make on the expressions below is the number of
  // consecutive </span> tags required.
  let lineRegex;
  if(charMode){
    lineRegex = new RegExp(/<span class\=[\"\']ocr_line[\s\S]+?(?:\<\/span\>\s*){3}/, "ig");
  } else {
    lineRegex = new RegExp(/<span class\=[\"\']ocr_line[\s\S]+?(?:\<\/span\>\s*){2}/, "ig");
  }


  const wordRegex = new RegExp(/<span class\=[\"\']ocrx_word[\s\S]+?(?:\<\/span\>\s*){2}/, "ig");
  const charRegex = new RegExp(/<span class\=[\"\']ocrx_cinfo[\"\'] title=\'([^\'\"]+)[\"\']\>([^\<]*)\<\/span\>/, "ig");
  const charBboxRegex = new RegExp(/bbox(?:es)?(\s+\d+)(\s+\d+)?(\s+\d+)?(\s+\d+)?/, "g");
  const wordElementRegex = new RegExp(/<span class\=[\"\']ocrx_word[^\>]+\>/, "i");
  //const wordTitleRegex = new RegExp(/(?<=title\=[\"\'])[^\"\']+/);

  // Remove all bold/italics tags.  These complicate the syntax and are unfortunately virtually always wrong anyway (coming from Tesseract).
  hocrString = hocrString.replaceAll(/<\/?strong>/ig, "");
  hocrString = hocrString.replaceAll(/<\/?em>/ig, "");

  // Delete namespace to simplify xpath
  hocrString = hocrString.replace(/<html[^>]*>/i, "<html>");

  // Replace various classes with "ocr_line" class for simplicity
  // At least in Tesseract, these elements are not identified accurately or consistently enough to warrent different treatment.
  hocrString = hocrString.replace(/(class=\')ocr_caption/ig, "$1ocr_line");
  hocrString = hocrString.replace(/(class=\')ocr_textfloat/ig, "$1ocr_line");
  hocrString = hocrString.replace(/(class=\')ocr_header/ig, "$1ocr_line");

  function convertLine(match){
    let titleStrLine = match.match(/title\=[\'\"]([^\'\"]+)/)?.[1];
    if (!titleStrLine) return;
    
    let linebox = [...titleStrLine.matchAll(/bbox(?:es)?(\s+\d+)(\s+\d+)?(\s+\d+)?(\s+\d+)?/g)][0].slice(1,5).map(function (x) {return parseInt(x)})

    // The baseline can be missing in the case of vertical text (textangle present instead)
    let baseline = [...titleStrLine.matchAll(/baseline(\s+[\d\.\-]+)(\s+[\d\.\-]+)/g)][0];
    if(baseline == null){
      return("");
    } else {
      baseline = baseline.slice(1,5).map(function (x) {return parseFloat(x)});
    }
    // Only calculate baselines from lines 200px+.
    // This avoids short "lines" (e.g. page numbers) that often report wild values.
    if((linebox[2] - linebox[0]) >= 200){
      angleRisePage.push(baseline[0]);
      lineLeft.push(linebox[0]);
      lineTop.push(linebox[1]);
    }

    let letterHeight = parseFloat(titleStrLine.match(/x_size\s+([\d\.\-]+)/)[1]);
    let ascHeight = titleStrLine.match(/x_ascenders\s+([\d\.\-]+)/);
    ascHeight = ascHeight == null ? null : parseFloat(ascHeight[1]);
    let descHeight = titleStrLine.match(/x_descenders\s+([\d\.\-]+)/);
    descHeight = descHeight == null ? null : parseFloat(descHeight[1]);

    // The only known scenario where letterHeight, ascHeight, and descHeight are not all defined
    // is when Abbyy data is loaded, HOCR is exported, and then that HOCR is re-imported.
    // As this HOCR is always at the word-level, convertWord is never run, so it does not matter
    // that xHeight is left undefined.
    let xHeight;
    if(letterHeight != null && ascHeight != null && descHeight != null){
       xHeight = letterHeight - ascHeight - descHeight;
    }

    function convertWord(match){
       let text = "";
       //let it = match.matchAll(/<span class\=[\"\']ocrx_cinfo[\"\'] title=\'([^\'\"]+)[\"\']\>([^\<]*)\<\/span\>/ig);
       let it = match.matchAll(charRegex);
       let letterArr = [...it];
       let bboxes = Array(letterArr.length);
       let cuts = Array(letterArr.length);

       // Unlike Abbyy, which generally identifies small caps as lowercase letters (and identifies small cap text explicitly as a formatting property),
       // Tesseract (at least the Legacy model) reports them as upper-case letters.
      let wordStr = letterArr.map(x => x[2]).join(""); heightObjPage
       let smallCaps = false;
       if(!/[a-z]/.test(wordStr) && /[A-Z].?[A-Z]/.test(wordStr)){
         let wordBboxesTop = letterArr.map(x => x[1].match(/\d+ (\d+)/)[1]);
         let wordBboxesBottom = letterArr.map(x => x[1].match(/\d+ \d+ \d+ (\d+)/)[1]);
         if(Math.min(...letterArr.map(x => x[1].match(/\d+ (\d+)/)[1]).map(x => Math.sign((x - wordBboxesBottom[0]) + ((wordBboxesBottom[0] - wordBboxesTop[0]) * 0.8))).slice(1)) == 1){
           smallCaps = true;
         }
       }


       for (let j = 0; j < letterArr.length; j++) {
        let titleStrLetter = letterArr[j][1];
        let contentStrLetter = letterArr[j][2];
        bboxes[j] = [...titleStrLetter.matchAll(charBboxRegex)][0].slice(1,5).map(function (x) {return parseInt(x)});

        // Multiple characters within a single <ocrx_cinfo> tag have been observed from Tesseract (even when set to char-level output).
        // May cause future issues as this code assumes one character per <ocrx_cinfo> tag.
         let charUnicode = String(contentStrLetter.charCodeAt(0));

        const charWidth = bboxes[j][2] - bboxes[j][0];
        const charHeight = bboxes[j][3] - bboxes[j][1];

        if(smallCaps){
          if (j > 0) {
            // If word is small caps, convert any letter but the first to lower case
            contentStrLetter = contentStrLetter.toLowerCase();
            charUnicode = String(contentStrLetter.charCodeAt(0));

            if(heightSmallCapsObjPage[charUnicode] == null){
              heightSmallCapsObjPage[charUnicode] = new Array();
            }
            heightSmallCapsObjPage[charUnicode].push(charHeight / xHeight);
          }

        } else {
          if(widthObjPage["normal"][charUnicode] == null){
            widthObjPage["normal"][charUnicode] = new Array();
            heightObjPage["normal"][charUnicode] = new Array();
          }

          // Skip letters likely misidentified due to hallucination effect (where e.g. "v" is misidentified as "V") or small caps
          if(!(/[A-Z]/.test(contentStrLetter) && (charHeight / xHeight) < 1.2)){
          //if(!(["V","O"].includes(charUnicode) && (charHeight / xHeight) < 1.2)){

            widthObjPage["normal"][charUnicode].push(charWidth / xHeight);
            heightObjPage["normal"][charUnicode].push(charHeight / xHeight);
          }

          if(j == 0){
            cuts[j] = 0;
          } else {
            cuts[j] = bboxes[j][0] - bboxes[j-1][2];

            var bigramUnicode = letterArr[j-1][2].charCodeAt(0) + "," + letterArr[j][2].charCodeAt(0);
            var cuts_ex = cuts[j] / xHeight;

            if(cutObjPage["normal"][charUnicode] == null){
              cutObjPage["normal"][charUnicode] = new Array();
            }
            cutObjPage["normal"][charUnicode].push(cuts_ex);

            if(kerningObjPage["normal"][bigramUnicode] == null){
              kerningObjPage["normal"][bigramUnicode] = new Array();
            }
            kerningObjPage["normal"][bigramUnicode].push(cuts_ex);
          }
        }

        text = text + contentStrLetter;
      }
      text = text ?? "";
      text = text.trim()

      if (text == "") return ("");

      let wordXML = match.match(wordElementRegex)[0];

      if (smallCaps) {
        wordXML = wordXML.slice(0, -1) + " style='font-variant:small-caps'" + ">";
      }

      return (wordXML + text + "</span>");

    }
    if(charMode){
      match = match.replaceAll(wordRegex, convertWord);
    }

    return(match);
  }


  hocrString = hocrString.replaceAll(lineRegex, convertLine);


  let angleRiseMedian = mean50(angleRisePage);


  let lineLeftAdj = new Array;
  for(let i = 0; i < lineLeft.length; i++){
    lineLeftAdj.push(lineLeft[i] + angleRiseMedian * lineTop[i]);
  }

  const angleOut = Math.asin(angleRiseMedian) * (180/Math.PI);

  let leftOut = quantile(lineLeft, 0.2);
  let leftAdjOut = quantile(lineLeftAdj, 0.2) - leftOut;
  // With <5 lines either a left margin does not exist (e.g. a photo or title page) or cannot be reliably determined
  if(lineLeft.length < 5){
    leftOut = null;
  }

  const xmlOut = hocrString;
  const dimsOut = pageDims;

  const widthOut = widthObjPage;
  const heightOut = heightObjPage;
  const heightSmallCapsOut = heightSmallCapsObjPage;
  const cutOut = cutObjPage;
  const kerningOut = kerningObjPage;

  const message_out = charMode ? "" : "char_warning";

  return([xmlOut,dimsOut,angleOut,leftOut,leftAdjOut,widthOut,heightOut,heightSmallCapsOut,cutOut,kerningOut,message_out]);

}


const abbyyDropCapRegex = new RegExp(/\<par dropCapCharsCount\=[\'\"](\d*)/, "i");
const abbyyLineBoxRegex = new RegExp(/\<line baseline\=[\'\"](\d*)[\'\"] l\=[\'\"](\d*)[\'\"] t\=[\'\"](\d*)[\'\"] r\=[\'\"](\d*)[\'\"] b\=[\'\"](\d*)[\'\"]\>/, "i");
const abbyySplitRegex = new RegExp(/(?:\<charParams[^\>]*\>\s*\<\/charParams\>)|(?:\<\/formatting\>\s*(?=\<formatting))/, "ig");

const abbyyCharRegex = new RegExp(/(\<formatting[^\>]+\>\s*)?\<charParams l\=[\'\"](\d*)[\'\"] t\=[\'\"](\d*)[\'\"] r\=[\'\"](\d*)[\'\"] b\=[\'\"](\d*)[\'\"](?: suspicious\=[\'\"](\w*)[\'\"])?[^\>]*\>([^\<]*)\<\/charParams\>/, "ig");

function convertPageAbbyy(xmlPage, pageNum){
  // Return early if character-level data is not detected.
  // Unlike Tesseract HOCR (which by default returns word-level data which we can still use), Abbyy XML returns line-level data that is not usable.
  let pageDims = xmlPage.match(/<page width=[\'\"](\d+)[\'\"] height=[\'\"](\d+)[\'\"]/);
  pageDims = [parseInt(pageDims[2]),parseInt(pageDims[1])];

  if(!/\<charParams/i.test(xmlPage)){
    return(["",pageDims,null,null,null,new Object,new Object,new Object,new Object,new Object,"char_error"])
  }

  let widthObjPage = new Object;
  let heightObjPage = new Object;
  let cutObjPage = new Object;
  let kerningObjPage = new Object;

  let lineLeft = new Array;
  let lineTop = new Array;

  // Includes all capital letters except for "J" and "Q"
  const ascCharArr = ["A","B","C","D","E","F","G","H","I","K","L","M","N","O","P","R","S","T","U","V","W","X","Y","Z","b","d","h","k","l","t","0","1","2","3","4","5","6","7","8","9"];
  const xCharArr = ["a","c","e","m","n","o","r","s","u","v","w","x","z"]

  function convertLineAbbyy(xmlLine, lineNum, pageNum = 1){
    let widthPxObjLine = new Object;
    let heightPxObjLine = new Object;
    let cutPxObjLine = new Object;
    let kerningPxObjLine = new Object;

    // Unlike Tesseract HOCR, Abbyy XML does not provide accurate metrics for determining font size, so they are calculated here.
    // Strangely, while Abbyy XML does provide a "baseline" attribute, it is often wildly incorrect (sometimes falling outside of the bounding box entirely).
    // One guess as to why is that coordinates calculated pre-dewarping are used along with a baseline calculated post-dewarping.
    // Regardless of the reason, baseline is recalculated here.
    let lineAscHeightArr = new Array();
    let lineXHeightArr = new Array();
    let lineAllHeightArr = new Array();
    let baselineHeightArr = new Array();
    let baselineSlopeArr = new Array();
    let baselineFirst = new Array();

    let dropCap = false;
    let dropCapMatch = xmlLine.match(abbyyDropCapRegex);
    if(dropCapMatch != null && parseInt(dropCapMatch[1]) > 0){
      dropCap = true;
    }

    let lineBoxArr = xmlLine.match(abbyyLineBoxRegex);
    if(lineBoxArr == null) {return("")};
    lineBoxArr = [...lineBoxArr].map(function (x) {return parseInt(x)});
    // Only calculate baselines from lines 200px+.
    // This avoids short "lines" (e.g. page numbers) that often report wild values.
    if((lineBoxArr[4] - lineBoxArr[2]) >= 200){
      //angleRisePage.push(baseline[0]);
      lineLeft.push(lineBoxArr[2]);
      lineTop.push(lineBoxArr[3]);
    }


    // Unlike Tesseract, Abbyy XML does not have a native "word" unit (it provides only lines and letters).
    // Therefore, lines are split into words on either (1) a space character or (2) a change in formatting.
    //
    // These regex remove blank characters that happen next to changes in formatting to avoid making too many words.
    // Note: Abbyy is inconsistent regarding where formatting elements are placed.
    // Sometimes the <format> comes after the space between words, and sometimes it comes before the space between words.
    xmlLine = xmlLine.replaceAll(/(\<\/formatting\>\<formatting[^\>]*\>\s*)<charParams[^\>]*\>\s*\<\/charParams\>/ig, "$1")
    xmlLine = xmlLine.replaceAll(/\<charParams[^\>]*\>\s*\<\/charParams\>(\s*\<\/formatting\>\<formatting[^\>]*\>\s*)/ig, "$1")

    let wordStrArr = xmlLine.split(abbyySplitRegex);

    // Filter off any array elements that do not have a character.
    // (This can happen ocassionally, for example when multiple spaces are next to eachother.)
    // TODO: This will drop formatting information in edge cases--e.g. if a formatting element is followed by multiple spaces.
    // However, hopefully these are uncommon enough that they should not be a big issue.
    let filterArr = wordStrArr.map(x => /charParams/i.test(x));
    wordStrArr = wordStrArr.filter((r, i) => filterArr[i]);

    if(wordStrArr.length == 0) return(["", 0]);

    let bboxes = Array(wordStrArr.length);
    let cuts = Array(wordStrArr.length);
    let text = Array(wordStrArr.length);
    text = text.fill("");
    let styleArr = Array(wordStrArr.length);
    styleArr = styleArr.fill("normal");
    let wordSusp = Array(wordStrArr.length);
    wordSusp.fill(false);


    for(let i=0;i<wordStrArr.length;i++){
      let wordStr = wordStrArr[i];
      let letterArr = [...wordStr.matchAll(abbyyCharRegex)];

      if(typeof(letterArr[0][1]) != "undefined"){
        if(dropCap && i==0){
          styleArr[i] = "dropcap";
        } else if(/superscript\=[\'\"](1|true)/i.test(letterArr[0][1])){
          styleArr[i] = "sup";
        } else if(/italic\=[\'\"](1|true)/i.test(letterArr[0][1])){
          styleArr[i] = "italic";
        } else if(/smallcaps\=[\'\"](1|true)/i.test(letterArr[0][1])) {
          styleArr[i] = "small-caps";
        } else {
          styleArr[i] = "normal";
        }
      } else {
        if(i > 0){
          if(styleArr[i-1] == "dropcap"){
            styleArr[i] = "normal";
          } else {
            styleArr[i] = styleArr[i-1];
          }
        }
      }

      // Abbyy will sometimes misidentify capital letters immediately following drop caps as small caps,
      // when they are only small in relation to the drop cap (rather than the main text).
      let dropCapFix = false;
      if(dropCap && i==1 && styleArr[i] == "small-caps"){
        styleArr[i] = "normal";
        dropCapFix = true;
      }


      bboxes[i] = new Array();
      cuts[i] = new Array();

      for(let j=0;j<letterArr.length;j++){
        // Skip letters placed at coordinate 0 (not sure why this happens)
        if(letterArr[j][2] == "0"){continue};
        bboxes[i][j] = new Array();
        bboxes[i][j].push(parseInt(letterArr[j][2]));
        bboxes[i][j].push(parseInt(letterArr[j][3]));
        bboxes[i][j].push(parseInt(letterArr[j][4]));
        bboxes[i][j].push(parseInt(letterArr[j][5]));

        let letterSusp = false;
        if(letterArr[j][6] == "1" || letterArr[j][6] == "true"){
          letterSusp = true;
          wordSusp[i] = true;
        }

        if(dropCapFix){
          letterArr[j][7] = letterArr[j][7].toUpperCase();
        }

         let contentStrLetter = letterArr[j][7];
         text[i] = text[i] + contentStrLetter;

        lineAllHeightArr.push(bboxes[i][j][3] - bboxes[i][j][1]);
        // Record height for different types of characters (used for calculating font size)
        // Only full sized characters are included (no superscripts)
        if (styleArr[i] != "sup") {
          if (ascCharArr.includes(contentStrLetter)) {
            lineAscHeightArr.push(bboxes[i][j][3] - bboxes[i][j][1]);
          } else if (xCharArr.includes(contentStrLetter)) {
            lineXHeightArr.push(bboxes[i][j][3] - bboxes[i][j][1]);
          }
        }

         if((ascCharArr.includes(contentStrLetter) || xCharArr.includes(contentStrLetter)) && !letterSusp && !dropCapFix && !(dropCap && i==0)){
           //baselineHeightArr.push(bboxes[i][j][3]);
           // To calculate the slope of the baseline (and therefore image angle) the position of each glyph that starts (approximately) on the
           // baseline is compared to the first such glyph.  This is less precise than a true "best fit" approach, but hopefully with enough data
           // points it will all average out.
           if(baselineFirst.length == 0){
             baselineFirst.push(bboxes[i][j][0], bboxes[i][j][3]);
           } else {

             baselineSlopeArr.push((bboxes[i][j][3] - baselineFirst[1]) / (bboxes[i][j][0] - baselineFirst[0]));

           }
         }

         const charUnicode = String(contentStrLetter.charCodeAt(0));
         const charWidth = bboxes[i][j][2] - bboxes[i][j][0];
        const charHeight = bboxes[i][j][3] - bboxes[i][j][1];
        
        if (!widthPxObjLine[styleArr[i]]) {
          widthPxObjLine[styleArr[i]] = new Array();
          heightPxObjLine[styleArr[i]] = new Array();
        }

        if (widthPxObjLine[styleArr[i]][charUnicode] == null){
          widthPxObjLine[styleArr[i]][charUnicode] = new Array();
          heightPxObjLine[styleArr[i]][charUnicode] = new Array();
         }
        widthPxObjLine[styleArr[i]][charUnicode].push(charWidth);
        heightPxObjLine[styleArr[i]][charUnicode].push(charHeight);

         if(j == 0){
           cuts[i][j] = 0;
         } else {
           cuts[i][j] = bboxes[i][j][0] - bboxes[i][j-1][2];

           var bigramUnicode = letterArr[j-1][7].charCodeAt(0) + "," + letterArr[j][7].charCodeAt(0);
           // Quick fix so it runs--need to figure out how to calculate x-height from Abbyy XML
           var cuts_ex = cuts[i][j];

           if (!cutPxObjLine[styleArr[i]]) {
             cutPxObjLine[styleArr[i]] = new Array();
           }

           if (cutPxObjLine[styleArr[i]][charUnicode] == null){
             cutPxObjLine[styleArr[i]][charUnicode] = new Array();
           }
           cutPxObjLine[styleArr[i]][charUnicode].push(cuts_ex);

           if (!kerningPxObjLine[styleArr[i]]) {
             kerningPxObjLine[styleArr[i]] = new Array();
           }

           if (kerningPxObjLine[styleArr[i]][bigramUnicode] == null){
             kerningPxObjLine[styleArr[i]][bigramUnicode] = new Array();
           }
           kerningPxObjLine[styleArr[i]][bigramUnicode].push(cuts_ex);
         }
       }
     }

     const lineAllHeight = Math.max(...lineAllHeightArr);
     let lineAscHeight = quantile(lineAscHeightArr, 0.5);
    const lineXHeight = quantile(lineXHeightArr, 0.5);
    
    if (lineXHeight != null) {
      for (const [style, obj] of Object.entries(widthPxObjLine)) {
        if (widthObjPage[style] == null) {
          widthObjPage[style] = new Array();
        }
        for (const [key, value] of Object.entries(obj)) {
          if (parseInt(key) < 33) { continue };

          if (widthObjPage[style][key] == null) {
            widthObjPage[style][key] = new Array();
          }
          for (let k = 0; k < value.length; k++) {
            widthObjPage[style][key].push(value[k] / lineXHeight);
          }
        }
      }

      for (const [style, obj] of Object.entries(heightPxObjLine)) {
        if (heightObjPage[style] == null) {
          heightObjPage[style] = new Array();
        }
        for (const [key, value] of Object.entries(obj)) {
          if (parseInt(key) < 33) { continue };

          if (heightObjPage[style][key] == null) {
            heightObjPage[style][key] = new Array();
          }
          for (let k = 0; k < value.length; k++) {
            heightObjPage[style][key].push(value[k] / lineXHeight);
          }
        }
      }


      for (const [style, obj] of Object.entries(cutPxObjLine)) {
        if (cutObjPage[style] == null) {
          cutObjPage[style] = new Array();
        }
        for (const [key, value] of Object.entries(obj)) {
          if (parseInt(key) < 33) { continue };

          if (cutObjPage[style][key] == null) {
            cutObjPage[style][key] = new Array();
          }
          for (let k = 0; k < value.length; k++) {
            cutObjPage[style][key].push(value[k] / lineXHeight);
          }
        }
      }

      for (const [style, obj] of Object.entries(kerningPxObjLine)) {
        if (kerningObjPage[style] == null) {
          kerningObjPage[style] = new Array();
        }
        for (const [key, value] of Object.entries(obj)) {
          if (parseInt(key) < 33) { continue };

          if (kerningObjPage[style][key] == null) {
            kerningObjPage[style][key] = new Array();
          }
          for (let k = 0; k < value.length; k++) {
            kerningObjPage[style][key].push(value[k] / lineXHeight);
          }
        }
      }

     }

     // While Abbyy XML already provides line bounding boxes, these have been observed to be (at times)
     // completely different than a bounding box calculated from a union of all letters in the line.
     // Therefore, the line bounding boxes are recaclculated here.
     let lineBoxArrCalc = new Array(4);
     lineBoxArrCalc[0] = Math.min(...bboxes.flat().map(x => x[0]).filter(x => x > 0));
     lineBoxArrCalc[1] = Math.min(...bboxes.flat().map(x => x[1]).filter(x => x > 0));
     lineBoxArrCalc[2] = Math.max(...bboxes.flat().map(x => x[2]).filter(x => x > 0));
     lineBoxArrCalc[3] = Math.max(...bboxes.flat().map(x => x[3]).filter(x => x > 0));

     const baselineSlope = baselineSlopeArr.length == 0 ? 0 : quantile(baselineSlopeArr, 0.5);

     const baselinePoint = baselineFirst[1] - lineBoxArrCalc[3] - baselineSlope * (baselineFirst[0] - lineBoxArrCalc[0]);

     let xmlOut = "<span class='ocr_line' title=\"bbox " + lineBoxArrCalc[0] + " " + lineBoxArrCalc[1] + " " + lineBoxArrCalc[2] + " " + lineBoxArrCalc[3];
     if(baselineSlopeArr.length > 0){
       xmlOut = xmlOut + "; baseline " + round6(baselineSlope) + " " + Math.round(baselinePoint);
     }
    
    // Calculate character size metrics (x_size, x_ascenders, x_descenders)
    // Ideally we would be able to calculate all 3 directly, however given this is not always possible,
    // different calculations are used based on the data available.

    // If no ascenders exist on the line but x-height is known, set ascender height to 1.5x x-height
    // (This is a quick fix--this logic may be refined later)
    if (!lineAscHeight && lineXHeight) {
      lineAscHeight = Math.round(lineXHeight * 1.5);
    }

    // Add character height (misleadingly called "x_size" in Tesseract hocr)
    xmlOut = xmlOut + "; x_size " + lineAllHeight;
    // If x-height exists, calculate x_ascenders (in addition to x_descenders)
    // In general, x-height must be a plausible value (to avoid obviously misidentified characters from determining font size).
    // This restriction is not applied for lines with small caps. 
    if (lineAscHeight && lineXHeight && (styleArr.includes("small-caps") || (lineAscHeight > lineXHeight * 1.1) && (lineAscHeight < lineXHeight * 2))) {
      xmlOut = xmlOut + "; x_ascenders " + (lineAscHeight - lineXHeight) + "; x_descenders " + (lineAllHeight - lineAscHeight);
      // Otherwise, add only x_descenders
    } else if (lineAscHeight) {
      // console.log("Rejecting xheight: " + lineXHeight, + " " + lineAscHeight + " on page " + pageNum);
      // console.log(text);
      xmlOut = xmlOut + "; x_descenders " + (lineAllHeight - lineAscHeight);
    }
    


     xmlOut = xmlOut + "\">";


     for(let i=0;i<text.length;i++){
       if(text[i].trim() == "") {continue};
        let bboxesI = bboxes[i];
       const bboxesILeft = bboxesI[0][0];
       // Abbyy XML can strangely give coordinates of 0 (this has been observed for some but not all superscripts), so these must be filtered out,
       // and it cannot be assumed that the rightmost letter has the maximum x coordinate.
       // TODO: Figure out why this happens and whether these glyphs should be dropped completely.
       const bboxesIRight = Math.max(...bboxesI.map(x => x[2]));

       const bboxesITop = Math.min(...bboxesI.map(x => x[1]).filter(x => x > 0));
       const bboxesIBottom = Math.max(...bboxesI.map(x => x[3]));
         
       if(!isFinite(bboxesITop) || !isFinite(bboxesIBottom)){
         continue;
       }

       xmlOut = xmlOut + "<span class='ocrx_word' id='word_" + (pageNum+1) + "_" + (lineNum+1) + "_" + (i+1) + "' title='bbox " + bboxesILeft + " " + bboxesITop + " " + bboxesIRight + " " + bboxesIBottom;
       if(wordSusp[i]){
         xmlOut = xmlOut + ";x_wconf 0";
       } else {
         xmlOut = xmlOut + ";x_wconf 100";
       }
      xmlOut = xmlOut + "\'"
      if(styleArr[i] == "italic"){
        xmlOut = xmlOut + " style='font-style:italic'" + ">" + text[i] + "</span>";;
      } else if(styleArr[i] == "small-caps"){
        xmlOut = xmlOut + " style='font-variant:small-caps'" + ">" + text[i] + "</span>";
      } else if(styleArr[i] == "sup"){
        xmlOut = xmlOut + ">" + "<sup>" + text[i] + "</sup>" + "</span>";
      } else if(styleArr[i] == "dropcap"){
        xmlOut = xmlOut + ">" + "<span class='ocr_dropcap'>" + text[i] + "</span>" + "</span>";
      } else {
        xmlOut = xmlOut + ">" + text[i] + "</span>";
      }

     }
     xmlOut = xmlOut + "</span>"
     return([xmlOut, baselineSlope]);
  }


  let lineStrArr = xmlPage.split(/\<\/line\>/);

  let xmlOut = "<div class='ocr_page'";

  xmlOut = xmlOut + " title='bbox 0 0 " + pageDims[1] + " " + pageDims[0] + "'>";

  let angleRisePage = new Array();
  for(let i=0;i<lineStrArr.length;i++){
    const lineInt = convertLineAbbyy(lineStrArr[i], i, pageNum);
    if(lineInt[0] == "") continue;
    angleRisePage.push(lineInt[1]);
    xmlOut = xmlOut + lineInt[0];
  }
  xmlOut = xmlOut + "</div>";

  let angleRiseMedian = mean50(angleRisePage);

  const angleOut = Math.asin(angleRiseMedian) * (180/Math.PI);


  let lineLeftAdj = new Array;
  for(let i = 0; i < lineLeft.length; i++){
    lineLeftAdj.push(lineLeft[i] + angleRiseMedian * lineTop[i]);
  }
  let leftOut = quantile(lineLeft, 0.2);
  let leftAdjOut = quantile(lineLeftAdj, 0.2) - leftOut;
  // With <5 lines either a left margin does not exist (e.g. a photo or title page) or cannot be reliably determined
  if(lineLeft.length < 5){
    leftOut = null;
  }

  const dimsOut = pageDims;
  const widthOut = widthObjPage;
  const heightOut = heightObjPage;
  const cutOut = cutObjPage;
  const kerningOut = kerningObjPage;
  return([xmlOut,dimsOut,angleOut,leftOut,leftAdjOut,widthOut,heightOut,new Object,cutOut,kerningOut,""]);

}
